int i = 0;
int *p1 = &(++i); //正确
int *p2 = &(i++); //错误

++i = 1; //正确
i++ = 5; //错误

那么为什么『i++ 不能作为左值，而++i 可以』？
左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。
一般来说，左值是可以放到赋值符号左边的变量。但能否被赋值不是区分左值与右值的依据。
比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。左值与右值的
根本区别在于是否允许取地址&运算符获得对应的内存地址。


// 前缀形式：
int& int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用
{//函数本身无参，意味着是在自身空间内增加1的
  *this += 1;  // 增加
  return *this;  // 取回值
}

//后缀形式:
const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。
{//函数带参，说明有另外的空间开辟
  int oldValue = *this;  // 取回值
  ++(*this);  // 增加
  return oldValue;  // 返回被取回的值
}
如上所示，i++ 最后返回的是一个临时变量，而临时变量是右值。