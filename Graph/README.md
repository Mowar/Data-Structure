# Graph
This is about the basic operation of the code

### 实验内容：
		（1）	键盘输入数据，分别建立一个有向图和一个无向图的邻接表。
		（2）	输出该邻接表。
		（3）	在有向图的邻接表的基础上计算各顶点的度，并输出。
		（4）	采用邻接表存储实现无向图的深度优先遍历。
		（5）	采用邻接表存储实现无向图的广度优先遍历。
		（6）	在主函数中设计一个简单的菜单，分别调试上述算法。
		（7）	*综合训练地下迷宫探索：假设有一个地下通道迷宫，它的通道都是直的，而通道所有交叉点（包括通道的端点）上都有一盏灯和一个开关。请问你如何从某个起点开始在迷宫中点亮所有的灯并回到起点？
>  
输入格式：
> 输入第一行给出三个正整数，分别表示地下迷宫的节点数N（\<N≤1000，表示通道
> 所有交叉点和端点）、边数M（M≤3000，表示通道数）和探索起始节点编号>S（节点从1到N编
> 号）。随后的M行对应M条边（通道），每行给出一对正整数，分别是该条边直接连通的两个节
> 点的编号。
> 
输出格式：
>若可以点亮所有节点的灯，则输出从S开始并以S结束的包含所有节点的序列，序列
>中相邻的节点一定有边（通道）；否则虽然不能点亮所有节点的灯，但还是输出点亮部分灯的
>节点序列，最后输出0，此时表示迷宫不是连通图。由于深度优先遍历的节点序列是不唯一的，
>为了使得输出具有唯一的结果，我们约定以节点小编号优先的次序访问（点灯）。在点亮所有
>可以点亮的灯后，以原路返回的方式回到起点。

![](https://github.com/YSZYCF/Graph/blob/master/image001.jpg?raw=true)

输入样例：
>
> 6 8 1
> 
> 1 2
> 
> 2 3
> 
> 3 4
> 
> 4 5
> 
> 5 6
> 
> 6 4
> 
> 3 6
> 
> 1 5


输出样例：
> 1 2 3 4 5 6 5 4 3 2 1

### 实验说明：     
		1．类型定义（邻接表存储）
        	#define MAX_VERTEX_NUM 20  //顶点最大个数
        	typedef struct ArcNode{
           		int            adjvex;
           		struct ArcNode *nextarc;
           		int            weight;  //边的权值
        	}ArcNode;  //表结点         
		
		#define VertexType int  //顶点元素类型
		
        	typedef struct VNode{  
           		VertexType data;
           		ArcNode *firstarc;
        	}VNode, AdjList[MAX_VERTEX_NUM]; //
		
        	typedef struct{
  			AdjList vertices;
          		int vexnum, arcnum; //顶点的实际数，边的实际数
          		int kind;			  //图的种类标识
       		}ALGraph;  
		2．上述类型定义可以根据实际情况适当调整。
		3．算法4、5分别利用栈、队列实现非递归算法。

### 注意问题：
		1．注意理解各算法实现时所采用的存储结构。
		2．注意区别正、逆邻接


### 注意事项
>1. 代码的编码方式是GB2312
>2. 工程的平台是[vs2010](https://www.visualstudio.com/zh-hans/downloads/)
>3. 代码在*.cpp | *.h 文件中.ALgraph.cpp实现了大多数功能，
